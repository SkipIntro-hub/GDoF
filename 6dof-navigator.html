<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>6DoF Prompt Navigator - Docking Simulator</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #0f0;
            overflow: hidden;
        }
        
        #root {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        .container {
            width: 100%;
            height: 100%;
            display: flex;
        }
        
        /* 3D Canvas */
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        /* Panels */
        .panel {
            position: relative;
            z-index: 10;
            background: rgba(0, 20, 0, 0.85);
            border: 2px solid #0f0;
            padding: 20px;
            width: 320px;
            height: 100vh;
            overflow-y: auto;
        }
        
        .panel-left {
            border-right: none;
        }
        
        .panel-right {
            border-left: none;
            margin-left: auto;
        }
        
        .panel h2 {
            color: #0ff;
            border-bottom: 2px solid #0ff;
            padding-bottom: 10px;
            margin-bottom: 20px;
            font-size: 16px;
        }
        
        /* Axis Control */
        .axis-control {
            margin-bottom: 30px;
        }
        
        .axis-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .axis-name {
            color: #ff0;
            font-weight: bold;
        }
        
        .axis-value {
            color: #0ff;
            font-size: 18px;
            font-weight: bold;
        }
        
        .axis-slider {
            width: 100%;
            height: 30px;
            background: #001100;
            border: 1px solid #0f0;
            position: relative;
            cursor: pointer;
        }
        
        .axis-track {
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 2px;
            background: #0f0;
            transform: translateY(-50%);
        }
        
        .axis-marker {
            position: absolute;
            top: 50%;
            width: 16px;
            height: 16px;
            background: #0ff;
            border: 2px solid #fff;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            cursor: grab;
            box-shadow: 0 0 10px #0ff;
        }
        
        .axis-marker:active {
            cursor: grabbing;
        }
        
        .axis-limits {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            color: #0a0;
            margin-top: 5px;
        }
        
        .axis-description {
            font-size: 11px;
            color: #0a0;
            margin-top: 5px;
            line-height: 1.4;
        }
        
        /* HUD Central */
        .hud {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 20;
            background: rgba(0, 20, 0, 0.9);
            border: 2px solid #0ff;
            padding: 20px;
            min-width: 500px;
            text-align: center;
        }
        
        .hud-title {
            color: #0ff;
            font-size: 20px;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .hud-status {
            font-size: 16px;
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid #0f0;
        }
        
        .status-approaching { color: #ff0; }
        .status-aligned { color: #0f0; }
        .status-docked { color: #0ff; animation: pulse 1s infinite; }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        .telemetry-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }
        
        .telemetry-item {
            background: rgba(0, 50, 0, 0.5);
            border: 1px solid #0a0;
            padding: 8px;
            text-align: left;
        }
        
        .telem-label {
            color: #0a0;
            font-size: 11px;
        }
        
        .telem-value {
            color: #0ff;
            font-size: 14px;
            font-weight: bold;
        }
        
        .telem-target {
            color: #0f0;
            font-size: 11px;
            margin-top: 3px;
        }
        
        .telem-delta {
            font-size: 11px;
            margin-top: 3px;
        }
        
        .delta-positive { color: #f00; }
        .delta-negative { color: #f00; }
        .delta-aligned { color: #0f0; }
        
        .distance-display {
            margin-top: 15px;
            padding: 10px;
            background: rgba(0, 50, 0, 0.5);
            border: 1px solid #0f0;
        }
        
        .distance-label {
            color: #0a0;
            font-size: 12px;
        }
        
        .distance-value {
            color: #0ff;
            font-size: 24px;
            font-weight: bold;
        }
        
        /* Navigation Card */
        .nav-card {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 30;
            background: rgba(0, 20, 0, 0.95);
            border: 3px solid #0ff;
            padding: 30px;
            max-width: 700px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 0 50px #0ff;
        }
        
        .nav-card h2 {
            color: #0ff;
            text-align: center;
            margin-bottom: 20px;
            font-size: 24px;
        }
        
        .nav-card-section {
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(0, 50, 0, 0.3);
            border: 1px solid #0a0;
        }
        
        .nav-card-section h3 {
            color: #ff0;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .nav-card-section p {
            color: #0f0;
            line-height: 1.6;
            font-size: 13px;
        }
        
        .prompt-box {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #0ff;
            padding: 15px;
            margin-top: 10px;
            white-space: pre-wrap;
            font-size: 12px;
            line-height: 1.6;
            color: #0ff;
        }
        
        .nav-card-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            justify-content: center;
        }
        
        .btn {
            background: #0a0;
            color: #000;
            border: 2px solid #0f0;
            padding: 10px 20px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        .btn:hover {
            background: #0f0;
            box-shadow: 0 0 20px #0f0;
        }
        
        .btn-primary {
            background: #0aa;
            border-color: #0ff;
        }
        
        .btn-primary:hover {
            background: #0ff;
            box-shadow: 0 0 20px #0ff;
        }
        
        /* Keyboard Hints */
        .keyboard-hints {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 20;
            background: rgba(0, 20, 0, 0.85);
            border: 1px solid #0a0;
            padding: 10px 20px;
            font-size: 11px;
            color: #0a0;
        }
        
        .keyboard-hints strong {
            color: #0f0;
        }
        
        /* Preset Selector */
        .preset-selector {
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(0, 50, 0, 0.3);
            border: 1px solid #0f0;
        }
        
        .preset-selector select {
            width: 100%;
            background: #001100;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 8px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
        }
        
        .preset-selector option {
            background: #001100;
            color: #0f0;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;
        
        // Presets de navegaciÃ³n
        const PRESETS = {
            neutral: {
                name: "Neutral - Punto de inicio",
                coords: { X: 0, Y: 0, Z: 0, Roll: 0, Pitch: 0, Yaw: 0 }
            },
            creative: {
                name: "Creative Exploration",
                coords: { X: -8, Y: 3, Z: 7, Roll: -45, Pitch: 30, Yaw: 0 }
            },
            strategic: {
                name: "Strategic Analysis",
                coords: { X: -5, Y: -6, Z: 4, Roll: 45, Pitch: 60, Yaw: 90 }
            },
            production: {
                name: "Content Production",
                coords: { X: 6, Y: 8, Z: 9, Roll: 0, Pitch: -70, Yaw: 270 }
            },
            pitch: {
                name: "Pitch Development",
                coords: { X: 2, Y: 4, Z: 6, Roll: -90, Pitch: -20, Yaw: 180 }
            },
            diagnosis: {
                name: "Problem Diagnosis",
                coords: { X: -7, Y: -8, Z: 5, Roll: 90, Pitch: 70, Yaw: 90 }
            },
            prototype: {
                name: "Rapid Prototyping",
                coords: { X: 4, Y: 7, Z: 10, Roll: -135, Pitch: -40, Yaw: 270 }
            }
        };
        
        // Descripciones de ejes
        const AXIS_INFO = {
            X: {
                name: "EJE X - FOCO",
                leftLabel: "Apertura",
                rightLabel: "Recorte",
                getDescription: (val) => {
                    if (val < -5) return "Alta apertura - ExploraciÃ³n divergente";
                    if (val < -2) return "Apertura moderada - ExploraciÃ³n controlada";
                    if (val <= 2) return "Equilibrio - Problema definido y flexible";
                    if (val <= 5) return "Recorte moderado - Enfoque especÃ­fico";
                    return "Alto recorte - MÃ¡xima especificidad";
                }
            },
            Y: {
                name: "EJE Y - PROFUNDIDAD",
                leftLabel: "Fundamento",
                rightLabel: "EjecuciÃ³n",
                getDescription: (val) => {
                    if (val < -5) return "FilosÃ³fico - Primeros principios";
                    if (val < -2) return "EstratÃ©gico - Conceptos y frameworks";
                    if (val <= 2) return "Arquitectura - DiseÃ±o de sistemas";
                    if (val <= 5) return "TÃ¡ctico - ImplementaciÃ³n prÃ¡ctica";
                    return "Operativo - ProducciÃ³n de outputs";
                }
            },
            Z: {
                name: "EJE Z - ITERACIÃ“N",
                leftLabel: "Slow",
                rightLabel: "Fast",
                getDescription: (val) => {
                    if (val < -5) return "Ciclos largos - Alta deliberaciÃ³n";
                    if (val < -2) return "Ritmo moderado - Balance reflexiÃ³n/acciÃ³n";
                    if (val <= 2) return "Ritmo normal - Progreso constante";
                    if (val <= 5) return "Ciclos cortos - ExperimentaciÃ³n activa";
                    return "MÃ¡xima velocidad - Aprendizaje exponencial";
                }
            },
            Roll: {
                name: "ROLL - PERSPECTIVA",
                leftLabel: "Creativo",
                rightLabel: "TÃ©cnico",
                getDescription: (deg) => {
                    const normalized = ((deg % 360) + 360) % 360;
                    if (normalized < 45) return "Neutro - Enfoque balanceado";
                    if (normalized < 90) return "TÃ©cnico - Engineering-first";
                    if (normalized < 135) return "AnalÃ­tico - Data-driven";
                    if (normalized < 180) return "SistÃ©mico - VisiÃ³n holÃ­stica";
                    if (normalized < 225) return "Inverso - Pensamiento contrarian";
                    if (normalized < 270) return "Humano - User-centered";
                    if (normalized < 315) return "Comercial - Business value";
                    return "Creativo - Design thinking";
                }
            },
            Pitch: {
                name: "PITCH - CONCRECIÃ“N",
                leftLabel: "AcciÃ³n",
                rightLabel: "VisiÃ³n",
                getDescription: (deg) => {
                    if (deg < -60) return "Output directo - ProducciÃ³n tÃ¡ctica";
                    if (deg < -30) return "ImplementaciÃ³n - EjecuciÃ³n prÃ¡ctica";
                    if (deg <= 30) return "Balance - Arquitectura y diseÃ±o";
                    if (deg <= 60) return "Estrategia - Frameworks conceptuales";
                    return "VisiÃ³n - Alto nivel estratÃ©gico";
                }
            },
            Yaw: {
                name: "YAW - INTENCIÃ“N",
                leftLabel: "Explorar",
                rightLabel: "Ejecutar",
                getDescription: (deg) => {
                    const normalized = ((deg % 360) + 360) % 360;
                    if (normalized < 45 || normalized >= 315) return "Explorar - Generar opciones";
                    if (normalized < 135) return "Resolver - Encontrar soluciÃ³n";
                    if (normalized < 225) return "Convencer - Argumentar persuasivamente";
                    return "Ejecutar - Producir deliverable";
                }
            }
        };
        
        // Three.js Scene Component
        function ThreeScene({ coordinates }) {
            const canvasRef = useRef(null);
            const sceneRef = useRef(null);
            const rendererRef = useRef(null);
            const cameraRef = useRef(null);
            const targetRef = useRef(null);
            const particlesRef = useRef(null);
            
            useEffect(() => {
                if (!canvasRef.current) return;
                
                // Setup scene
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x000000);
                sceneRef.current = scene;
                
                // Camera
                const camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                camera.position.z = 50;
                cameraRef.current = camera;
                
                // Renderer
                const renderer = new THREE.WebGLRenderer({ 
                    canvas: canvasRef.current,
                    antialias: true 
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                rendererRef.current = renderer;
                
                // Lights
                const ambientLight = new THREE.AmbientLight(0x00ff00, 0.3);
                scene.add(ambientLight);
                
                const pointLight = new THREE.PointLight(0x00ffff, 1, 100);
                pointLight.position.set(0, 0, 20);
                scene.add(pointLight);
                
                // Target Sphere (Problem Space)
                const targetGeometry = new THREE.SphereGeometry(5, 32, 32);
                const targetMaterial = new THREE.MeshPhongMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.3,
                    wireframe: true
                });
                const target = new THREE.Mesh(targetGeometry, targetMaterial);
                scene.add(target);
                targetRef.current = target;
                
                // Coordinate axes
                const axesHelper = new THREE.AxesHelper(20);
                scene.add(axesHelper);
                
                // Particle cloud
                const particlesGeometry = new THREE.BufferGeometry();
                const particlesCount = 1000;
                const positions = new Float32Array(particlesCount * 3);
                
                for (let i = 0; i < particlesCount * 3; i++) {
                    positions[i] = (Math.random() - 0.5) * 100;
                }
                
                particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const particlesMaterial = new THREE.PointsMaterial({
                    color: 0x00ff00,
                    size: 0.5,
                    transparent: true,
                    opacity: 0.6
                });
                
                const particles = new THREE.Points(particlesGeometry, particlesMaterial);
                scene.add(particles);
                particlesRef.current = particles;
                
                // Animation loop
                function animate() {
                    requestAnimationFrame(animate);
                    
                    if (targetRef.current) {
                        targetRef.current.rotation.y += 0.005;
                    }
                    
                    if (particlesRef.current) {
                        particlesRef.current.rotation.y += 0.001;
                    }
                    
                    renderer.render(scene, camera);
                }
                animate();
                
                // Handle resize
                const handleResize = () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                };
                window.addEventListener('resize', handleResize);
                
                return () => {
                    window.removeEventListener('resize', handleResize);
                    renderer.dispose();
                };
            }, []);
            
            // Update scene based on coordinates
            useEffect(() => {
                if (!sceneRef.current || !targetRef.current) return;
                
                // Calculate distance to target
                const distance = Math.sqrt(
                    Math.pow(coordinates.X / 10, 2) +
                    Math.pow(coordinates.Y / 10, 2) +
                    Math.pow(coordinates.Z / 10, 2) +
                    Math.pow(coordinates.Roll / 180, 2) +
                    Math.pow(coordinates.Pitch / 180, 2) +
                    Math.pow(coordinates.Yaw / 180, 2)
                );
                
                // Update target color based on proximity
                if (distance < 0.5) {
                    targetRef.current.material.color.setHex(0x00ffff);
                    targetRef.current.material.opacity = 0.6;
                } else if (distance < 2) {
                    targetRef.current.material.color.setHex(0x00ff00);
                    targetRef.current.material.opacity = 0.5;
                } else if (distance < 5) {
                    targetRef.current.material.color.setHex(0xffff00);
                    targetRef.current.material.opacity = 0.4;
                } else {
                    targetRef.current.material.color.setHex(0xff0000);
                    targetRef.current.material.opacity = 0.3;
                }
                
                // Update camera position based on coordinates
                if (cameraRef.current) {
                    cameraRef.current.position.x = -coordinates.X * 0.5;
                    cameraRef.current.position.y = -coordinates.Y * 0.5;
                    cameraRef.current.position.z = 50 - coordinates.Z * 0.5;
                    
                    // Apply rotations
                    cameraRef.current.rotation.z = (coordinates.Roll * Math.PI) / 180;
                }
                
            }, [coordinates]);
            
            return <canvas ref={canvasRef} id="canvas-container" />;
        }
        
        // Axis Control Component
        function AxisControl({ label, value, min, max, onChange, info }) {
            const sliderRef = useRef(null);
            const [isDragging, setIsDragging] = useState(false);
            
            const handleMouseDown = (e) => {
                setIsDragging(true);
                updateValue(e);
            };
            
            const handleMouseMove = useCallback((e) => {
                if (isDragging) {
                    updateValue(e);
                }
            }, [isDragging]);
            
            const handleMouseUp = () => {
                setIsDragging(false);
            };
            
            const updateValue = (e) => {
                if (!sliderRef.current) return;
                const rect = sliderRef.current.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const percentage = Math.max(0, Math.min(1, x / rect.width));
                const newValue = min + percentage * (max - min);
                onChange(newValue);
            };
            
            useEffect(() => {
                if (isDragging) {
                    document.addEventListener('mousemove', handleMouseMove);
                    document.addEventListener('mouseup', handleMouseUp);
                    return () => {
                        document.removeEventListener('mousemove', handleMouseMove);
                        document.removeEventListener('mouseup', handleMouseUp);
                    };
                }
            }, [isDragging, handleMouseMove]);
            
            const percentage = ((value - min) / (max - min)) * 100;
            
            return (
                <div className="axis-control">
                    <div className="axis-label">
                        <span className="axis-name">{info.name}</span>
                        <span className="axis-value">{value.toFixed(1)}{label.includes('Roll') || label.includes('Pitch') || label.includes('Yaw') ? 'Â°' : ''}</span>
                    </div>
                    <div 
                        ref={sliderRef}
                        className="axis-slider"
                        onMouseDown={handleMouseDown}
                    >
                        <div className="axis-track" />
                        <div 
                            className="axis-marker"
                            style={{ left: `${percentage}%` }}
                        />
                    </div>
                    <div className="axis-limits">
                        <span>{info.leftLabel}</span>
                        <span>{info.rightLabel}</span>
                    </div>
                    <div className="axis-description">
                        {info.getDescription(value)}
                    </div>
                </div>
            );
        }
        
        // Navigation Card Component
        function NavigationCard({ coordinates, onClose, onCopy }) {
            const generatePrompt = () => {
                const roleMap = {
                    '-10to-7': 'FilÃ³sofo/Visionario',
                    '-7to-3': 'Estratega/Investigador',
                    '-3to3': 'Arquitecto/Consultor',
                    '3to7': 'Implementador/Builder',
                    '7to10': 'Ejecutor/Producer'
                };
                
                let role = 'Consultor General';
                const y = coordinates.Y;
                if (y <= -7) role = roleMap['-10to-7'];
                else if (y <= -3) role = roleMap['-7to-3'];
                else if (y <= 3) role = roleMap['-3to3'];
                else if (y <= 7) role = roleMap['3to7'];
                else role = roleMap['7to10'];
                
                const perspective = AXIS_INFO.Roll.getDescription(coordinates.Roll);
                const concretion = AXIS_INFO.Pitch.getDescription(coordinates.Pitch);
                const intention = AXIS_INFO.Yaw.getDescription(coordinates.Yaw);
                
                return `ActÃºa como un ${role} con perspectiva ${perspective.toLowerCase()}.

COORDENADAS DE NAVEGACIÃ“N:
- Foco: ${coordinates.X.toFixed(1)} (${AXIS_INFO.X.getDescription(coordinates.X)})
- Profundidad: ${coordinates.Y.toFixed(1)} (${AXIS_INFO.Y.getDescription(coordinates.Y)})
- IteraciÃ³n: ${coordinates.Z.toFixed(1)} (${AXIS_INFO.Z.getDescription(coordinates.Z)})
- Perspectiva: ${coordinates.Roll.toFixed(0)}Â° (${perspective})
- ConcreciÃ³n: ${coordinates.Pitch.toFixed(0)}Â° (${concretion})
- IntenciÃ³n: ${coordinates.Yaw.toFixed(0)}Â° (${intention})

CONTEXTO:
[Inserta aquÃ­ el problema o desafÃ­o especÃ­fico]

ENFOQUE:
- ${perspective}
- Nivel de output: ${concretion}
- Modalidad: ${intention}

INSTRUCCIONES:
1. Aborda el desafÃ­o desde la perspectiva definida
2. Genera ${coordinates.Z > 5 ? '3-5 opciones divergentes (iteraciÃ³n rÃ¡pida)' : '1-2 opciones bien desarrolladas'}
3. Entrega en formato ${coordinates.Pitch < -30 ? 'ejecutable inmediato' : 'conceptual con estructura'}

ENTREGABLE:
[Define el tipo de output esperado segÃºn tu necesidad especÃ­fica]`;
            };
            
            return (
                <div className="nav-card">
                    <h2>âœ… DOCKING EXITOSO</h2>
                    <div className="nav-card-section">
                        <h3>COORDENADAS FINALES</h3>
                        <p>
                            <strong>Traslaciones:</strong><br/>
                            â€¢ Foco: {coordinates.X.toFixed(1)} - {AXIS_INFO.X.getDescription(coordinates.X)}<br/>
                            â€¢ Profundidad: {coordinates.Y.toFixed(1)} - {AXIS_INFO.Y.getDescription(coordinates.Y)}<br/>
                            â€¢ IteraciÃ³n: {coordinates.Z.toFixed(1)} - {AXIS_INFO.Z.getDescription(coordinates.Z)}
                        </p>
                        <p style={{marginTop: '10px'}}>
                            <strong>Rotaciones:</strong><br/>
                            â€¢ Perspectiva: {coordinates.Roll.toFixed(0)}Â° - {AXIS_INFO.Roll.getDescription(coordinates.Roll)}<br/>
                            â€¢ ConcreciÃ³n: {coordinates.Pitch.toFixed(0)}Â° - {AXIS_INFO.Pitch.getDescription(coordinates.Pitch)}<br/>
                            â€¢ IntenciÃ³n: {coordinates.Yaw.toFixed(0)}Â° - {AXIS_INFO.Yaw.getDescription(coordinates.Yaw)}
                        </p>
                    </div>
                    
                    <div className="nav-card-section">
                        <h3>PROMPT GENERADO</h3>
                        <div className="prompt-box">
                            {generatePrompt()}
                        </div>
                    </div>
                    
                    <div className="nav-card-actions">
                        <button className="btn btn-primary" onClick={() => onCopy(generatePrompt())}>
                            COPIAR PROMPT
                        </button>
                        <button className="btn" onClick={onClose}>
                            NUEVA NAVEGACIÃ“N
                        </button>
                    </div>
                </div>
            );
        }
        
        // Main App Component
        function App() {
            const [coordinates, setCoordinates] = useState({
                X: 0, Y: 0, Z: 0,
                Roll: 0, Pitch: 0, Yaw: 0
            });
            
            const [isDocked, setIsDocked] = useState(false);
            const [selectedPreset, setSelectedPreset] = useState('neutral');
            
            // Target coordinates (can be customized)
            const target = {
                X: 0, Y: 0, Z: 5,
                Roll: 0, Pitch: 0, Yaw: 0
            };
            
            const TOLERANCES = {
                translation: 1.5,
                rotation: 15
            };
            
            // Calculate distance to target
            const calculateDistance = useCallback(() => {
                const dx = (coordinates.X - target.X) / 10;
                const dy = (coordinates.Y - target.Y) / 10;
                const dz = (coordinates.Z - target.Z) / 10;
                const dRoll = (coordinates.Roll - target.Roll) / 180;
                const dPitch = (coordinates.Pitch - target.Pitch) / 180;
                const dYaw = (coordinates.Yaw - target.Yaw) / 180;
                
                return Math.sqrt(dx**2 + dy**2 + dz**2 + dRoll**2 + dPitch**2 + dYaw**2);
            }, [coordinates, target]);
            
            // Check if docked
            const checkDocking = useCallback(() => {
                const aligned = {
                    X: Math.abs(coordinates.X - target.X) < TOLERANCES.translation,
                    Y: Math.abs(coordinates.Y - target.Y) < TOLERANCES.translation,
                    Z: Math.abs(coordinates.Z - target.Z) < TOLERANCES.translation,
                    Roll: Math.abs(coordinates.Roll - target.Roll) < TOLERANCES.rotation,
                    Pitch: Math.abs(coordinates.Pitch - target.Pitch) < TOLERANCES.rotation,
                    Yaw: Math.abs(coordinates.Yaw - target.Yaw) < TOLERANCES.rotation
                };
                
                return Object.values(aligned).every(v => v === true);
            }, [coordinates, target]);
            
            useEffect(() => {
                if (checkDocking() && !isDocked) {
                    setIsDocked(true);
                }
            }, [coordinates, checkDocking, isDocked]);
            
            // Keyboard controls
            useEffect(() => {
                const handleKeyDown = (e) => {
                    const speed = 0.5;
                    const rotSpeed = 5;
                    
                    setCoordinates(prev => {
                        const newCoords = { ...prev };
                        
                        switch(e.key.toLowerCase()) {
                            // Translations
                            case 'w': newCoords.X = Math.max(-10, prev.X - speed); break;
                            case 's': newCoords.X = Math.min(10, prev.X + speed); break;
                            case 'q': newCoords.Y = Math.max(-10, prev.Y - speed); break;
                            case 'e': newCoords.Y = Math.min(10, prev.Y + speed); break;
                            case 'a': newCoords.Z = Math.max(-10, prev.Z - speed); break;
                            case 'd': newCoords.Z = Math.min(10, prev.Z + speed); break;
                            
                            // Rotations
                            case 'i': newCoords.Pitch = Math.min(90, prev.Pitch + rotSpeed); break;
                            case 'k': newCoords.Pitch = Math.max(-90, prev.Pitch - rotSpeed); break;
                            case 'j': newCoords.Roll = prev.Roll - rotSpeed; break;
                            case 'l': newCoords.Roll = prev.Roll + rotSpeed; break;
                            case 'u': newCoords.Yaw = prev.Yaw - rotSpeed; break;
                            case 'o': newCoords.Yaw = prev.Yaw + rotSpeed; break;
                            
                            // Reset
                            case ' ':
                                return { X: 0, Y: 0, Z: 0, Roll: 0, Pitch: 0, Yaw: 0 };
                        }
                        
                        return newCoords;
                    });
                };
                
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, []);
            
            const handlePresetChange = (e) => {
                const preset = e.target.value;
                setSelectedPreset(preset);
                if (PRESETS[preset]) {
                    setCoordinates(PRESETS[preset].coords);
                    setIsDocked(false);
                }
            };
            
            const handleCopyPrompt = (prompt) => {
                navigator.clipboard.writeText(prompt);
                alert('Prompt copiado al clipboard!');
            };
            
            const distance = calculateDistance();
            const docked = checkDocking();
            
            let status = 'NAVEGANDO LIBREMENTE';
            let statusClass = 'status-approaching';
            
            if (docked) {
                status = 'âœ… DOCKED - READY TO GENERATE';
                statusClass = 'status-docked';
            } else if (distance < 2) {
                status = 'ðŸŸ¢ CASI ALINEADO - AJUSTE FINO';
                statusClass = 'status-aligned';
            } else if (distance < 5) {
                status = 'ðŸŸ¡ APROXIMACIÃ“N EN PROGRESO';
                statusClass = 'status-approaching';
            }
            
            return (
                <div className="container">
                    <ThreeScene coordinates={coordinates} />
                    
                    {/* Left Panel - Translations */}
                    <div className="panel panel-left">
                        <h2>BLOQUE 1: EL ESPACIO</h2>
                        
                        <div className="preset-selector">
                            <select value={selectedPreset} onChange={handlePresetChange}>
                                {Object.entries(PRESETS).map(([key, preset]) => (
                                    <option key={key} value={key}>{preset.name}</option>
                                ))}
                            </select>
                        </div>
                        
                        <AxisControl
                            label="X"
                            value={coordinates.X}
                            min={-10}
                            max={10}
                            onChange={(val) => setCoordinates(prev => ({ ...prev, X: val }))}
                            info={AXIS_INFO.X}
                        />
                        
                        <AxisControl
                            label="Y"
                            value={coordinates.Y}
                            min={-10}
                            max={10}
                            onChange={(val) => setCoordinates(prev => ({ ...prev, Y: val }))}
                            info={AXIS_INFO.Y}
                        />
                        
                        <AxisControl
                            label="Z"
                            value={coordinates.Z}
                            min={-10}
                            max={10}
                            onChange={(val) => setCoordinates(prev => ({ ...prev, Z: val }))}
                            info={AXIS_INFO.Z}
                        />
                    </div>
                    
                    {/* Right Panel - Rotations */}
                    <div className="panel panel-right">
                        <h2>BLOQUE 2: EL AJUSTE</h2>
                        
                        <AxisControl
                            label="Roll"
                            value={coordinates.Roll}
                            min={-180}
                            max={180}
                            onChange={(val) => setCoordinates(prev => ({ ...prev, Roll: val }))}
                            info={AXIS_INFO.Roll}
                        />
                        
                        <AxisControl
                            label="Pitch"
                            value={coordinates.Pitch}
                            min={-90}
                            max={90}
                            onChange={(val) => setCoordinates(prev => ({ ...prev, Pitch: val }))}
                            info={AXIS_INFO.Pitch}
                        />
                        
                        <AxisControl
                            label="Yaw"
                            value={coordinates.Yaw}
                            min={0}
                            max={360}
                            onChange={(val) => setCoordinates(prev => ({ ...prev, Yaw: val }))}
                            info={AXIS_INFO.Yaw}
                        />
                    </div>
                    
                    {/* HUD */}
                    <div className="hud">
                        <div className="hud-title">6DOF PROMPT NAVIGATOR</div>
                        <div className={`hud-status ${statusClass}`}>
                            {status}
                        </div>
                        
                        <div className="telemetry-grid">
                            <div className="telemetry-item">
                                <div className="telem-label">X-FOCO</div>
                                <div className="telem-value">{coordinates.X.toFixed(1)}</div>
                                <div className="telem-target">Target: {target.X.toFixed(1)}</div>
                                <div className={`telem-delta ${Math.abs(coordinates.X - target.X) < TOLERANCES.translation ? 'delta-aligned' : 'delta-positive'}`}>
                                    Î”: {(coordinates.X - target.X).toFixed(1)}
                                </div>
                            </div>
                            
                            <div className="telemetry-item">
                                <div className="telem-label">Y-PROFUNDIDAD</div>
                                <div className="telem-value">{coordinates.Y.toFixed(1)}</div>
                                <div className="telem-target">Target: {target.Y.toFixed(1)}</div>
                                <div className={`telem-delta ${Math.abs(coordinates.Y - target.Y) < TOLERANCES.translation ? 'delta-aligned' : 'delta-positive'}`}>
                                    Î”: {(coordinates.Y - target.Y).toFixed(1)}
                                </div>
                            </div>
                            
                            <div className="telemetry-item">
                                <div className="telem-label">Z-ITERACIÃ“N</div>
                                <div className="telem-value">{coordinates.Z.toFixed(1)}</div>
                                <div className="telem-target">Target: {target.Z.toFixed(1)}</div>
                                <div className={`telem-delta ${Math.abs(coordinates.Z - target.Z) < TOLERANCES.translation ? 'delta-aligned' : 'delta-positive'}`}>
                                    Î”: {(coordinates.Z - target.Z).toFixed(1)}
                                </div>
                            </div>
                            
                            <div className="telemetry-item">
                                <div className="telem-label">ROLL</div>
                                <div className="telem-value">{coordinates.Roll.toFixed(0)}Â°</div>
                                <div className="telem-target">Target: {target.Roll.toFixed(0)}Â°</div>
                                <div className={`telem-delta ${Math.abs(coordinates.Roll - target.Roll) < TOLERANCES.rotation ? 'delta-aligned' : 'delta-positive'}`}>
                                    Î”: {(coordinates.Roll - target.Roll).toFixed(0)}Â°
                                </div>
                            </div>
                            
                            <div className="telemetry-item">
                                <div className="telem-label">PITCH</div>
                                <div className="telem-value">{coordinates.Pitch.toFixed(0)}Â°</div>
                                <div className="telem-target">Target: {target.Pitch.toFixed(0)}Â°</div>
                                <div className={`telem-delta ${Math.abs(coordinates.Pitch - target.Pitch) < TOLERANCES.rotation ? 'delta-aligned' : 'delta-positive'}`}>
                                    Î”: {(coordinates.Pitch - target.Pitch).toFixed(0)}Â°
                                </div>
                            </div>
                            
                            <div className="telemetry-item">
                                <div className="telem-label">YAW</div>
                                <div className="telem-value">{coordinates.Yaw.toFixed(0)}Â°</div>
                                <div className="telem-target">Target: {target.Yaw.toFixed(0)}Â°</div>
                                <div className={`telem-delta ${Math.abs(coordinates.Yaw - target.Yaw) < TOLERANCES.rotation ? 'delta-aligned' : 'delta-positive'}`}>
                                    Î”: {(coordinates.Yaw - target.Yaw).toFixed(0)}Â°
                                </div>
                            </div>
                        </div>
                        
                        <div className="distance-display">
                            <div className="distance-label">DISTANCIA A TARGET</div>
                            <div className="distance-value">{distance.toFixed(2)}</div>
                        </div>
                    </div>
                    
                    {/* Keyboard Hints */}
                    <div className="keyboard-hints">
                        <strong>CONTROLES:</strong> W/S=Foco X | Q/E=Profundidad Y | A/D=IteraciÃ³n Z | 
                        I/K=Pitch | J/L=Roll | U/O=Yaw | SPACE=Reset
                    </div>
                    
                    {/* Navigation Card */}
                    {isDocked && (
                        <NavigationCard
                            coordinates={coordinates}
                            onClose={() => {
                                setIsDocked(false);
                                setCoordinates({ X: 0, Y: 0, Z: 0, Roll: 0, Pitch: 0, Yaw: 0 });
                            }}
                            onCopy={handleCopyPrompt}
                        />
                    )}
                </div>
            );
        }
        
        // Render
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
